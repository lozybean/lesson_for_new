printf "数组：\n";
#以匿名列表方式定义数组：
@a = ('a','b','c');
#＊不能是['a','b','c']，不然会变成一个匿名列表的引用，而由于@a存放的是数组，所以该引用会变成@a中的第一个值存放，具体会变为@a[0]->[1] == 'b'
#＊＊从这里还可以看出，perl的赋值操作是硬拷贝，在拷贝的时候根据左边容器的结构进行内存的拷贝操作
#＊＊perl同时支持符号引用，由于符号引用比较灵活，伴随着较大的风险，有兴趣的可以深入研究；
print "@a\n";  #在标量上下文并且认为是字符串的时候转为字符串
print 1+@a;  #在标量上下文认为是数字的时候转为数字
print "\n";
($a,$b,$c) = @a; #解析一个数组
print "$a\t$b\t$c\n"; #在列表上下文中认为是列表
#在这些转换中@a的数据结构并没有发生变化，只是perl解释器根据上下文做出的反应，将不同反应的结果呈现出来而已
#＊如果学习过python，这个操作可以类比于__str__()，__int__()等方法
#
#列表的访问：
print "$a[1]\t$a[2]\t$a[3]\n";

#如果要定义嵌套的数组应该这样：
print "数组的嵌套： \n";
@a = (['a','b','c'],['d','e','f']);
print "$a[0]->[1]\n"; # 现在是一个数组的引用，$a[2] 超出界限而不存在
@sub = ('a','b','c');
$y = \@sub;
print "$y\n";
# $y 和$a[0]等价
print "@${y}\n"; #解析一个数组的引用
#如果使用列表的方式会被解析平面化：
@a = (('a','b','c'),('d','e','f')); 
print "$a[0]\n"; # 现在是 ‘'a'，列表已经被平面化了， $a[2] 为'c'


print "数组的排序： \n";
@a = (1,3,2,5,4,11,15);
print "@a\n";
@a = sort @a;
print "@a\n";
@a = sort {$a<=>$b} @a;
print "@a\n";
# {} 这里是一个匿名代码块，

print "数组的链接：\n";
@a = ('a','b','c');
$a = join('#',@a);
print "$a\n";
#相对的，可以拆解$a：
@b = split /#/, $a;
print "@b\n";


